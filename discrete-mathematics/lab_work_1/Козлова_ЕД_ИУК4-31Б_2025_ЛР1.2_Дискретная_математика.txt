import collections

readers = {1, 2, 3, 4}

books = {"1984", "Марсианин", "Автостопом по галактике", "Ведьмак", "Властелин колец",
         "Сто лет одиночества", "Мастер и Маргарита", "Маленький принц"}
genres = {"Социальная фантастика", "Научная фантастика", "Комедия", "Фэнтези",
          "Эпическое фэнтези", "Магический реализм", "Роман", "Философская сказка"}

reader_to_book_dict = {
    1: {"1984", "Ведьмак"},
    2: {"Автостопом по галактике", "Властелин колец"},
    3: {"Мастер и Маргарита", "Маленький принц"},
    4: {"Сто лет одиночества"}
}

book_to_genre_dict = {
    "1984": "Социальная фантастика",
    "Марсианин": "Научная фантастика",
    "Автостопом по галактике": "Комедия",
    "Ведьмак": "Фэнтези", 
    "Властелин колец": "Эпическое фэнтези",
    "Сто лет одиночества": "Магический реализм",
    "Мастер и Маргарита": "Роман", 
    "Маленький принц": "Философская сказка"
}

print("Исходные множества и соответствия")
print("Читатели:", readers)
print("Книги:", books)
print("Жанры:", genres)
print("Читатель <- Книга (dict):", reader_to_book_dict)
print("Книга -> Жанр (dict):", book_to_genre_dict)
print("-" * 50)


def dict_to_pairs(mapping_dict, is_many_to_one=False):
    pairs = []
    if is_many_to_one:  
        for key, value in mapping_dict.items():
            pairs.append((key, value))
    else: 
        for key, values_set in mapping_dict.items():
            for value in values_set:
                pairs.append((key, value))
    return pairs

reader_to_book_pairs = dict_to_pairs(reader_to_book_dict, is_many_to_one=False)
book_to_genre_pairs = dict_to_pairs(book_to_genre_dict, is_many_to_one=True)


print("\nСоответствия в формате списка пар")
print("Читатель <- Книга (pairs):", reader_to_book_pairs)
print("Книга -> Жанр (pairs):", book_to_genre_pairs)
print("-" * 50)



def is_functional(pairs):
    domain_map = collections.defaultdict(list)
    for k, v in pairs:
        domain_map[k].append(v)
    
    for k, values in domain_map.items():
        if len(values) > 1:
            return False
    return True

def is_everywhere_defined(domain, pairs):
    if not domain: 
        return True
        
    actual_domain = set(p[0] for p in pairs)
    return domain.issubset(actual_domain)

def is_injective(pairs):

    if not is_functional(pairs):
        return False

    codomain_map = collections.defaultdict(list)
    for k, v in pairs:
        codomain_map[v].append(k)
    
    for v, keys in codomain_map.items():
        if len(keys) > 1:
            return False
    return True

def is_surjective(pairs, codomain):

    if not codomain:
        return True

    actual_codomain = set(p[1] for p in pairs)
    return codomain.issubset(actual_codomain)

def image(pairs, subset_A):

    result_image = set()
    for k, v in pairs:
        if k in subset_A:
            result_image.add(v)
    return result_image

def preimage(pairs, subset_B):

    result_preimage = set()
    for k, v in pairs:
        if v in subset_B:
            result_preimage.add(k)
    return result_preimage

def proj_A(pairs):

    return set(p[0] for p in pairs)

def proj_B(pairs):

    return set(p[1] for p in pairs)

def compose_via(f_pairs, g_pairs):

    g_map = collections.defaultdict(set)
    for b_val, c_val in g_pairs:
        g_map[b_val].add(c_val)
    
    composed_pairs = []
    for a_val, b_val_f in f_pairs:
        if b_val_f in g_map:
            for c_val_g in g_map[b_val_f]:
                composed_pairs.append((a_val, c_val_g))
    
    return composed_pairs


print("\nРезультаты анализа свойств соответствий")

def analyze_relation(pairs, domain, codomain, name="Relation"):
    func = is_functional(pairs)
    ever_defined = is_everywhere_defined(domain, pairs)
    inj = is_injective(pairs)
    surj = is_surjective(pairs, codomain)

    print(f"\nАнализ '{name}':")
    print(f"  Функциональность (Functional): {func}")
    print(f"  Всюду определено на домене ({list(domain)}) (Everywhere Defined): {ever_defined}")
    print(f"  Инъективность (Injective): {inj}")
    print(f"  Сюръективность на кодомене ({list(codomain)}) (Surjective): {surj}")

    if func and ever_defined and inj and surj:
        print(f"  -> '{name}' является БИЕКТИВНЫМ соответствием.")
    elif func and ever_defined:
        print(f"  -> '{name}' является ФУНКЦИЕЙ.")
    else:
        print(f"  -> '{name}' не является функцией.")


analyze_relation(reader_to_book_pairs, readers, books, name="Читатель <- Книга")
analyze_relation(book_to_genre_pairs, books, genres, name="Книга -> Жанр")
print("-" * 50)


print("\nПримеры вычисления образа и прообраза")

print("\nОбраз и прообраз для 'Читатель <- Книга':")
subset_readers_1 = {1}
image_1 = image(reader_to_book_pairs, subset_readers_1)
print(f"  Образ читателей {subset_readers_1}: {image_1}") 

subset_books_1984 = {"1984"}
preimage_1984 = preimage(reader_to_book_pairs, subset_books_1984)
print(f"  Прообраз книг {subset_books_1984}: {preimage_1984}") 


print("\nОбраз и прообраз для 'Книга -> Жанр':")
subset_books_fantasy_scifi = {"Ведьмак", "Марсианин"}
image_genres = image(book_to_genre_pairs, subset_books_fantasy_scifi)
print(f"  Образ книг {subset_books_fantasy_scifi}: {image_genres}")


subset_genres_scifi = {"Научная фантастика"}
preimage_scifi = preimage(book_to_genre_pairs, subset_genres_scifi)
print(f"  Прообраз жанров {subset_genres_scifi}: {preimage_scifi}")
print("-" * 50)


print("\nПроекции (proj_A, proj_B)")
print("\nПроекции для 'Читатель <- Книга':")
print(f"  proj_A (домен соответствия): {proj_A(reader_to_book_pairs)}")
print(f"  proj_B (область значений соответствия): {proj_B(reader_to_book_pairs)}")
print(f"  Убедимся, что proj_A == readers: {proj_A(reader_to_book_pairs) == readers}")
print(f"  Убедимся, что proj_B ⊆ books: {proj_B(reader_to_book_pairs).issubset(books)}")

print("\nПроекции для 'Книга -> Жанр':")
print(f"  proj_A (домен соответствия): {proj_A(book_to_genre_pairs)}")
print(f"  proj_B (область значений соответствия): {proj_B(book_to_genre_pairs)}")
print(f"  Убедимся, что proj_A == books: {proj_A(book_to_genre_pairs) == books}")
print(f"  Убедимся, что proj_B ⊆ genres: {proj_B(book_to_genre_pairs).issubset(genres)}")
print("-" * 50)


print("\nПостроение композиции 'Читатель -> Жанр'")

reader_to_genre_pairs = compose_via(reader_to_book_pairs, book_to_genre_pairs)
print("Композиция 'Читатель -> Жанр' (pairs):", reader_to_genre_pairs)


analyze_relation(reader_to_genre_pairs, readers, genres, name="Читатель -> Жанр (Композиция)")
print("-" * 50)


print("\nПревращение соответствия в биекцию (пример)")

print("\nИсходное соответствие 'Книга -> Жанр' (book_to_genre_pairs) уже биективно после исправления опечатки!")
print("Повторный анализ 'Книга -> Жанр':")
analyze_relation(book_to_genre_pairs, books, genres, name="Книга -> Жанр (Повторно)")
